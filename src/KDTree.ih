/**
 * @file KDTree.ih
 * @author Thomas Caissard (\c thomas.caissard@gmail.com)
 * @date 2019/08/05
 */

#include "assert.h"

/********** KDPoint Functions Implementation *********/
template<class T, std::size_t N>
T distance(const std::array<T, N> &a, const std::array<T, N> &b)
{
  T d(0.0);
  for(std::size_t dim = 0; dim < N; ++dim)
    d += std::pow(a[dim] - b[dim], 2.0);

  assert(d >= T(0));

  return std::sqrt(d);
}

template <typename T, std::size_t N>
std::ostream &operator<<(std::ostream &out, const KDPoint<T, N>& p)
{
  out << "KDPoint[ ";
  for(std::size_t dim = 0; dim < N - 1; ++dim)
    out << p.point[dim] << ", ";
  out << p.point[N - 1] << " ]";

  return out;
}

/********** KDNode Functions Implementation *********/
template <typename T, std::size_t N>
std::ostream &operator<<(std::ostream &out, const KDNode<T, N>& n)
{
  if(!n.isLeaf())
  {
    out << "Simple Node. SplitVal=" << n.value->point[n.depth % N] << " " << *(n.value);
  }

  return out;
}

/********** KDTree Functions Implementation *********/
template <typename T, std::size_t N>
KDTree<T,N>::KDTree(KDPointArray &arr, const SplitFunction &splitFun)
  : splitFun(splitFun)
{
  assert(arr.size() >= 2);

  std::array<T,N> bMin, bMax;
  std::fill(bMin.begin(), bMin.end(), std::numeric_limits<T>::max());
  std::fill(bMax.begin(), bMax.end(), std::numeric_limits<T>::min());

  KDPointArray internalArr;
  for(auto const& n : arr)
  {
    for(std::size_t dim = 0; dim < N; ++dim)
    {
      bMin[dim] = std::min(n->point[dim], bMin[dim]);
      bMax[dim] = std::max(n->point[dim], bMax[dim]);
    }
    internalArr.push_back(n);
  }

  BoundingBox b(bMin, bMax);

  root = KDTree::makeTree(internalArr.begin(), internalArr.end(), b);
}

template <typename T, std::size_t N>
typename KDTree<T,N>::KDNodeUPtr KDTree<T,N>::makeTree(const ArrayIter &begin, 
      const ArrayIter &end,
      const BoundingBox<T,N> box,
      const std::size_t depth)
{
  assert(depth >= 0);

  const ArrayIter middle = splitFun(begin, end, depth);

  KDNodeUPtr left;
  BoundingBox lBox = box; lBox.max[depth % N] = (*middle)->point[depth % N];
  if(std::distance(begin, middle) > 0)
    left = makeTree(begin, middle, lBox, depth + 1);
  else left = nullptr;

  KDNodeUPtr right;
  BoundingBox rBox = box; rBox.min[depth % N] = (*middle)->point[depth % N];
  if(std::distance(middle + 1, end) > 0)
    right = makeTree(middle + 1, end, rBox, depth + 1);
  else right = nullptr;

  return std::make_unique<const KDNode<T,N>>(*middle, left, right, box);
}

template <typename T, std::size_t N>
const KDPoint<T,N> KDTree<T,N>::nearest(const std::array<T, N> &point) const
{
  KDPoint<T, N> closest({0.0, 0.0});
  T minDist = std::numeric_limits<T>::max();
  nearest(root, point, closest, minDist);
  return closest;
}

template <typename T, std::size_t N>
void KDTree<T,N>::nearest(const KDNodeUPtr &node,
    const std::array<T, N> &point,
    KDPoint<T, N> &closest,
    T &minDist,
    const std::size_t depth) const
{
  if(node == nullptr || node->isLeaf())
    return;

  if(!node->bb.hyperSphereIntersection(point, minDist))
    return;

  assert(node->value != nullptr);

  const T dist = distance(point, node->value->point); 
  if(dist < minDist)
  {
    minDist = dist;
    closest = *(node->value);
  }

  const size_t dim = depth % N;
  if(point[dim] <= node->value->point[dim])
  {
    nearest(node->left , point, closest, minDist, depth + 1);
    if(point[dim] + minDist >= node->value->point[dim]) 
      nearest(node->right, point, closest, minDist, depth + 1);
  }
  else
  {
    nearest(node->right, point, closest, minDist, depth + 1);
    if(point[dim] - minDist <= node->value->point[dim]) 
      nearest(node->left , point, closest, minDist, depth + 1);
  }
}

